"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    FILE_EXT_TO_READER: function() {
        return FILE_EXT_TO_READER;
    },
    SimpleDirectoryReader: function() {
        return SimpleDirectoryReader;
    },
    TextFileReader: function() {
        return TextFileReader;
    }
});
const _env = require("@llamaindex/env");
const _Node = require("../Node.js");
const _FileSystem = require("../storage/FileSystem.js");
const _CSVReader = require("./CSVReader.js");
const _DocxReader = require("./DocxReader.js");
const _HTMLReader = require("./HTMLReader.js");
const _ImageReader = require("./ImageReader.js");
const _MarkdownReader = require("./MarkdownReader.js");
const _PDFReader = require("./PDFReader.js");
var ReaderStatus;
(function(ReaderStatus) {
    ReaderStatus[ReaderStatus["STARTED"] = 0] = "STARTED";
    ReaderStatus[ReaderStatus["COMPLETE"] = 1] = "COMPLETE";
    ReaderStatus[ReaderStatus["ERROR"] = 2] = "ERROR";
})(ReaderStatus || (ReaderStatus = {}));
class TextFileReader {
    async loadData(file, fs = _env.defaultFS) {
        const dataBuffer = await fs.readFile(file);
        return [
            new _Node.Document({
                text: dataBuffer,
                id_: file
            })
        ];
    }
}
const FILE_EXT_TO_READER = {
    txt: new TextFileReader(),
    pdf: new _PDFReader.PDFReader(),
    csv: new _CSVReader.PapaCSVReader(),
    md: new _MarkdownReader.MarkdownReader(),
    docx: new _DocxReader.DocxReader(),
    htm: new _HTMLReader.HTMLReader(),
    html: new _HTMLReader.HTMLReader(),
    jpg: new _ImageReader.ImageReader(),
    jpeg: new _ImageReader.ImageReader(),
    png: new _ImageReader.ImageReader(),
    gif: new _ImageReader.ImageReader()
};
class SimpleDirectoryReader {
    observer;
    constructor(observer){
        this.observer = observer;
    }
    async loadData(params) {
        if (typeof params === "string") {
            params = {
                directoryPath: params
            };
        }
        const { directoryPath, fs = _env.defaultFS, defaultReader = new TextFileReader(), fileExtToReader = FILE_EXT_TO_READER } = params;
        // Observer can decide to skip the directory
        if (!this.doObserverCheck("directory", directoryPath, 0)) {
            return [];
        }
        const docs = [];
        for await (const filePath of (0, _FileSystem.walk)(fs, directoryPath)){
            try {
                const fileExt = _env.path.extname(filePath).slice(1).toLowerCase();
                // Observer can decide to skip each file
                if (!this.doObserverCheck("file", filePath, 0)) {
                    continue;
                }
                let reader;
                if (fileExt in fileExtToReader) {
                    reader = fileExtToReader[fileExt];
                } else if (defaultReader != null) {
                    reader = defaultReader;
                } else {
                    const msg = `No reader for file extension of ${filePath}`;
                    console.warn(msg);
                    // In an error condition, observer's false cancels the whole process.
                    if (!this.doObserverCheck("file", filePath, 2, msg)) {
                        return [];
                    }
                    continue;
                }
                const fileDocs = await reader.loadData(filePath, fs);
                // Observer can still cancel addition of the resulting docs from this file
                if (this.doObserverCheck("file", filePath, 1)) {
                    docs.push(...fileDocs);
                }
            } catch (e) {
                const msg = `Error reading file ${filePath}: ${e}`;
                console.error(msg);
                // In an error condition, observer's false cancels the whole process.
                if (!this.doObserverCheck("file", filePath, 2, msg)) {
                    return [];
                }
            }
        }
        // After successful import of all files, directory completion
        // is only a notification for observer, cannot be cancelled.
        this.doObserverCheck("directory", directoryPath, 1);
        return docs;
    }
    doObserverCheck(category, name, status, message) {
        if (this.observer) {
            return this.observer(category, name, status, message);
        }
        return true;
    }
}
