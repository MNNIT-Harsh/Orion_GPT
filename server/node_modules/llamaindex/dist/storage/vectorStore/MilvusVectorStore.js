/* eslint-disable turbo/no-undeclared-env-vars */ import { MilvusClient } from "@zilliz/milvus2-sdk-node";
import { Document, MetadataMode } from "../../Node.js";
export class MilvusVectorStore {
    storesText = true;
    isEmbeddingQuery;
    milvusClient;
    collection = "";
    idKey;
    contentKey;
    metadataKey;
    embeddingKey;
    constructor(init){
        if (init?.milvusClient) {
            this.milvusClient = init.milvusClient;
        } else {
            const configOrAddress = init?.params?.configOrAddress ?? process.env.MILVUS_ADDRESS;
            const ssl = init?.params?.ssl ?? process.env.MILVUS_SSL === "true";
            const username = init?.params?.username ?? process.env.MILVUS_USERNAME;
            const password = init?.params?.password ?? process.env.MILVUS_PASSWORD;
            if (!configOrAddress) {
                throw new Error("Must specify MILVUS_ADDRESS via env variable.");
            }
            this.milvusClient = new MilvusClient(configOrAddress, ssl, username, password, init?.params?.channelOptions);
        }
        this.idKey = init?.idKey ?? "id";
        this.contentKey = init?.contentKey;
        this.metadataKey = init?.metadataKey ?? "metadata";
        this.embeddingKey = init?.embeddingKey ?? "embedding";
    }
    client() {
        return this.milvusClient;
    }
    async connect(collection) {
        await this.milvusClient.connectPromise;
        await this.milvusClient.loadCollectionSync({
            collection_name: collection
        });
        this.collection = collection;
    }
    async add(nodes) {
        if (!this.collection) {
            throw new Error("Must connect to collection before adding.");
        }
        const result = await this.milvusClient.insert({
            collection_name: this.collection,
            data: nodes.map((node)=>{
                const entry = {
                    [this.idKey]: node.id_,
                    [this.embeddingKey]: node.getEmbedding(),
                    [this.metadataKey]: node.metadata ?? {}
                };
                if (this.contentKey) {
                    entry[this.contentKey] = String(node.getContent(MetadataMode.NONE));
                }
                return entry;
            })
        });
        if (!result.IDs) {
            return [];
        }
        if ("int_id" in result.IDs) {
            return result.IDs.int_id.data.map((i)=>String(i));
        }
        return result.IDs.str_id.data.map((s)=>String(s));
    }
    async delete(refDocId, deleteOptions) {
        await this.milvusClient.delete({
            ids: [
                refDocId
            ],
            collection_name: this.collection,
            ...deleteOptions
        });
    }
    async query(query, _options) {
        if (!this.collection) {
            throw new Error("Must connect to collection before querying.");
        }
        const found = await this.milvusClient.search({
            collection_name: this.collection,
            limit: query.similarityTopK,
            vector: query.queryEmbedding
        });
        return {
            nodes: found.results.map((result)=>{
                return new Document({
                    id_: result[this.idKey],
                    metadata: result[this.metadataKey] ?? {},
                    text: this.contentKey ? result[this.contentKey] : JSON.stringify(result),
                    embedding: result[this.embeddingKey]
                });
            }),
            similarities: found.results.map((result)=>result.score),
            ids: found.results.map((result)=>String(result.id))
        };
    }
    async persist() {
    // no need to do anything
    }
}
